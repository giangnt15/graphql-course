GraphQL Scalar types:
    Int: A signed 32‐bit integer.
    Float: A signed double-precision floating-point value.
    String: A UTF‐8 character sequence.
    Boolean: true or false.
    ID: The ID scalar type represents a unique identifier, 
        often used to refetch an object or as the key for a cache. 
        The ID type is serialized in the same way as a String; 
        however, defining it as an ID signifies that it is not intended to be human‐readable.

Schema: define what data look likes and what to do with data
resolvers: run when a query, mutation or subscription is called, it knows how to get or mutate the data
=> resolvers object structure mirrors the structure of Schema
=> the data returned from a resolver must match up with the fields of the type it returns
for example: 
const typeDefs = `
    type User{
        id: ID!
        name: String!
        email: String!
        age: Int!
    }

    type Query{
        me: User!
    }

`
const resolvers = {
    Query: {
        me(){
            return {
                id: "123",
                name: "Giang",
                email: "giangqwerty69@gmail.com"
            }
        }
    }
}

=> a mutation or a query without arguments list can stripe out "()" (like above)
=> note that the resolver doesn't return age => if a client try to fetch age => error because age is an required field
=> either return age from resolver or remove "!" from age

Non-scalar types: Array or custom types (object types): 
Non-scalar types contain other non-scalar types or scalar types

type MyType{
    myField: String! # the "!" show that this is an required field, it always is (return) a string, not null
    myField2: [String!]! #the outer "!" shows that this is an required field, always is an array, not null
                        # the inner "!" shows that this is an array of type String, it can be empty but
                        # if it has value, the value must be a String, not null, not any other types
}
=> the value return from resolver of the field decorated with "!" must not be null

every resolver is injected with for arguments: parent, args, ctx, info, including custom type's resolver
 - args is where the arguments from the client live (it contains all the arguments sent from the client)
type Query{
        me: User!
        users(query: String): [User!]! #query is optional, if query is not passed, remove the "()" from the client query
        add(a: Float!, b: Float!): Float!
        post: Post!
        getPostById(id: ID!): Post!
        posts: [Post!]!
}
e.g : {                 
  users{
    id
    name
    email
    age
  }
}
{
  users(query:"a"){
    id
    name
    email
    age
  }
If a query, a mutation or a subscription return an object of a custom type or an array of objects of the custom type, if that custom type have a resolver,  
that resolver will be called for each object of the array, that resolver is injected with the parent parameter pointing to the object being consider (the object is of the custom type returned) => 
we can determine what can be return to the client here, for example we can stripe out sensitive infomation such as password, email,... or we
can use it to return the relational data => the value returned from that field resolver will override the corresponding field value of the object => the client will recieve the 
value returned from the field resolver

- selection set is applied only to an array of object type or to an object type itself
- selection set example: 
    query getAllsBooks{
        getBooks{
            id
            title
        }
    }
-selection set for an array: select fields in each object of the array
e.g: 
    query getAllsBooks{
        getBooks{
            id
            title
            comments{ #comment is an array
                id
                content
            }
        }
    }
=> return something like {
    "data": {
        "getBooks": [{
            "id": "someID",
            "title": "someTitle",
            "comments": [{
                "id": "commentID",
                "content": "commentContent"
            },{
                ...
            }]
        },{...}]
    }
}

- input types can only have scalar types
- if a field is of an enum type, the value returned from that field must be one of the
    constant of the enum type